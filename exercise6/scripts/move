#!/usr/bin/env python
from __future__ import print_function
from tf.transformations import quaternion_from_euler

import sys
import rospy
import dlib
import cv2
import numpy as np
import tf2_geometry_msgs
import tf2_ros
import math
import cv2
import actionlib
import matplotlib.pyplot as plt

from skimage.morphology import skeletonize
from move_base_msgs.msg import MoveBaseAction, MoveBaseGoal, MoveBaseActionResult
from std_msgs.msg import String
#import matplotlib.pyplot as plt
from sensor_msgs.msg import Image
from geometry_msgs.msg import PointStamped, Vector3, Pose, Twist, TransformStamped, PoseWithCovarianceStamped
from cv_bridge import CvBridge, CvBridgeError
from visualization_msgs.msg import Marker, MarkerArray
from std_msgs.msg import ColorRGBA
from nav_msgs.msg import OccupancyGrid
from skimage.util import invert
from exercise6.msg import objs_info
from sound_play.libsoundplay import SoundClient
 
x_current = 270
y_current = 280 
x_previous = 270
y_previous = 320
map_resolution = 0
map_transform = TransformStamped()
heigth = 0
width = 0

def move_bot(client, x,y, xPrev, yPrev):

    global map_transform
    global map_resolution

    pt = PointStamped()
    pt.point.x = x * map_resolution
    pt.point.y = (heigth - y) * map_resolution
    pt.point.z = 0.0

    pose_transformed = tf2_geometry_msgs.do_transform_point(pt, map_transform)


    ptPrev = PointStamped()
    ptPrev.point.x = xPrev * map_resolution
    ptPrev.point.y = (heigth - yPrev) * map_resolution
    ptPrev.point.z = 0.0

    pose_transformedPrev = tf2_geometry_msgs.do_transform_point(ptPrev, map_transform)

    angle = np.arctan2((pose_transformed.point.y-pose_transformedPrev.point.y),(pose_transformed.point.x-pose_transformedPrev.point.x))


    print("Sending to: ", pose_transformed.point.x, " ", pose_transformed.point.y, " angle: ", angle)

   
    q = quaternion_from_euler(0,0,angle)

    
    goal = MoveBaseGoal()
    goal.target_pose.header.frame_id = "map"
    goal.target_pose.header.stamp = rospy.Time.now()
    goal.target_pose.pose.position.x = pose_transformed.point.x
    goal.target_pose.pose.position.y = pose_transformed.point.y
    goal.target_pose.pose.position.z = 0.0
    goal.target_pose.pose.orientation.x = q[0]
    goal.target_pose.pose.orientation.y = q[1]
    goal.target_pose.pose.orientation.z = q[2]
    goal.target_pose.pose.orientation.w = q[3]
    client.send_goal(goal)


    '''
    try:
        rinfo = rospy.wait_for_message("move_base/status", GoalStatusArray)
    except Exception as e:
        print(e)

    print("wait")
    state = client.get_state()
    if state != 1:
        print("skipping goal, state:",state)
    '''
        

    wait = client.wait_for_result()
    print(wait)

    if not wait:
        rospy.logerr("Action server not available!")
        rospy.signal_shutdown("Action server not available!")
    else:
        result = client.get_result()
        if result:
            print("goal reached!") 
        else:
            print("big oof")  

def move_bot_rings(client, x,y, skeleton):

    global map_transform
    global map_resolution
    global heigth 
    global width

    min_d=1000
    xgoal=0
    ygoal=0

    print("bot at ", x, " ", y)


    #find nearest possible goal on the skeleton
    for i in xrange(heigth):
        for j in xrange(width):
            if skeleton[i][j] == 1:

                pt = PointStamped()
                pt.point.x = j * map_resolution
                pt.point.y = (heigth - i) * map_resolution
                pt.point.z = 0.0

                pose_transformed = tf2_geometry_msgs.do_transform_point(pt, map_transform)


                x2=pose_transformed.point.x
                y2=pose_transformed.point.y

                if  euclidian_distance(x,y,x2,y2) < min_d:
                    min_d = euclidian_distance(x,y,x2,y2)
                    xgoal = x2
                    ygoal = y2

    #print("xgoal, ygoal : ", xgoal, ygoal)                

    angle = np.arctan2((y-ygoal),(x-xgoal))


    print("Sending to face the ring: @[",x, ", ", y,"] ",  xgoal, " ", ygoal, " angle: ", angle)

   
    q = quaternion_from_euler(0,0,angle)

    
    goal = MoveBaseGoal()
    goal.target_pose.header.frame_id = "map"
    goal.target_pose.header.stamp = rospy.Time.now()
    goal.target_pose.pose.position.x = xgoal
    goal.target_pose.pose.position.y = ygoal
    goal.target_pose.pose.position.z = 0.0
    goal.target_pose.pose.orientation.x = q[0]
    goal.target_pose.pose.orientation.y = q[1]
    goal.target_pose.pose.orientation.z = q[2]
    goal.target_pose.pose.orientation.w = q[3]

    client.send_goal(goal)
    wait = client.wait_for_result()

    if not wait:
        rospy.logerr("Action server not available!")
        rospy.signal_shutdown("Action server not available!")
    else:
        result = client.get_result()
        if result:
            print("ring reached!") 
        else:
            print("big oof")  
  



def next_goal(client,map, r, width, heigth):

    max_d=0
    goalx=0
    goaly=0
    global x_current 
    global y_current
    r2=15
    r3=r2


    for i in xrange(-r,r,1):
       for j in xrange(-r,r,1):

           y = i + y_current
           x = j + x_current

           if map[y][x] == 1:

                if i > -r2 and i < r2 and j > -r2 and j < r2:
                    map[y][x] = 0
                if euclidian_distance(x,y ,x_current, y_current) > max_d:

                    max_d = euclidian_distance(x,y ,x_current, y_current)
                    goalx= x
                    goaly= y

    if goalx == 0 and goaly == 0:

        goals_count=0
        min_d = 1000

        for i in xrange(heigth):
            for j in xrange(width): 

               if map[i][j] == 1:
                    goals_count= goals_count+1

                    if euclidian_distance(j,i ,x_current, y_current) < min_d:
                        
                        min_d = euclidian_distance(j,i ,x_current, y_current)
                        goalx= j
                        goaly= i
        if goals_count < 5:
          print("space explored! ", goals_count)
          goalx=-1
        else:

            #check if there is a goal already set nearby
            for i in xrange(-r3,r3,1):
              for j in xrange(-r3,r3,1):
                y = i + goaly
                x = j + goalx

                if map[y][x] == 1:
                   map[y][x] = 0

                if map[y][x] == 180 and ( y != goaly or x != goalx ):
                    goalx = x_current
                    goaly = y_current
                           
            if goalx ==  x_current and goaly == y_current:
                print("break, point too close to already visited point!")
            else:
                print("break, number of goals: ",goals_count)
                map[goaly][goalx] = 180  

    else:
        map[goaly][goalx] = 180
              
   
            
    
    print(goalx, " ", goaly)
    x_previous  = x_current
    y_previous = y_current

    x_current=goalx
    y_current=goaly
     

    if goalx != -1:
    
     move_bot(client,x_current,y_current,x_previous, y_previous)

    return  map
           





def euclidian_distance(x,y ,x2, y2):
    return math.sqrt(math.pow(abs(x-x2),2) + math.pow(abs(y-y2),2))


def main():

    global width
    global heigth
    global map_transform
    global map_resolution

    rospy.init_node("move")
    soundhandle = SoundClient()

    try:
        map = rospy.wait_for_message("map", OccupancyGrid)
    except Exception as e:
        print(e)

    width=map.info.width
    heigth=map.info.height

    
    print(map.info)    
    cv_map = np.zeros((heigth,width))
    mask = np.zeros((heigth,width))
    walls = np.zeros((heigth,width))
    move_map = np.zeros((heigth,width))
    rgb = np.zeros((heigth,width,3))

    print(cv_map.shape)
    
    map_resolution = map.info.resolution

    map_transform = TransformStamped()
    map_transform.transform.translation.x = map.info.origin.position.x
    map_transform.transform.translation.y = map.info.origin.position.y
    map_transform.transform.translation.z = map.info.origin.position.z
    map_transform.transform.rotation = map.info.origin.orientation
  
  
    x=0
    for i in xrange(heigth-1,-1,-1):
        for j in xrange(width):
            
            
            if map.data[x] == -1 : 
             cv_map[i][j] = 0
             mask[i][j] = 1
           
            if map.data[x] == 0 :
             cv_map[i][j] = 0
            

            if map.data[x] == 100 : 
             cv_map[i][j] = 1
             walls[i][j] = 1
            
            x=x+1



    kernel = np.ones((10,10),np.uint8)
    dilatedOriginal = cv2.dilate(cv_map, kernel ,iterations = 1)

    dilated = invert(dilatedOriginal)
 
    skeleton = skeletonize(dilated)

    for i in xrange(heigth):
        for j in xrange(width):
            
          if mask[i][j]  == 1:
            skeleton[i][j] = 0
                

    ## use move_map for exploration
    ## 1 == possible goal
    ## 0 == free space
    ## 170 == outside the polygon
    ## 100 == wall
    
    for i in range(heigth):
        for j in range(width):
            if skeleton[i][j] == 1:
                rgb[i][j][1] = 150
                move_map[i][j] = 1

            if mask[i][j] == 1:
               rgb[i][j][2] = 150
               move_map[i][j] = 170

            if walls[i][j] == 1:
               rgb[i][j][0] = 150
               move_map[i][j] = 100



    try:
        pose = rospy.wait_for_message("/amcl_pose", PoseWithCovarianceStamped)
        #TO DO: get initial pose
     
    except Exception as e:
        print(e)
   

    client = actionlib.SimpleActionClient('move_base',MoveBaseAction)
    client.wait_for_server()

    print("hello")
    
    
    #send turtlebot to initial point for testing purposes
    move_bot(client,x_current,y_current, x_previous, y_previous)

    # TODO delete comment ''' and test!
    
    rings_info = objs_info()
    rings_info.poses, rings_info.colors = [], []
  
    
    while x_current != -1:
        move_map= next_goal(client,move_map,20,width,heigth)

        # TODO delete comment ''' and test!
        
        try:
            rinfo = rospy.wait_for_message("rings_info", objs_info)
        except Exception as e:
            print(e)
        # TODO move to (under?) the ring
        i = 0
        while len(rings_info.poses) < len(rinfo.poses):
        
            
            # get new ring pose and color
            rings_info.poses = np.append (rings_info.poses, rinfo.poses[len(rinfo.poses) - 1-i]) 
            rings_info.colors = np.append (rings_info.colors, rinfo.colors[len(rinfo.poses) - 1-i]) 
            i=i+1

            # TODO move to (under?) the ring
            print("FOUND NEW RING")
            print(len(rinfo.poses))
           
            move_bot_rings(client, rinfo.poses[len(rinfo.poses) - 1-i].position.x,rinfo.poses[len(rinfo.poses) - 1-i].position.y, skeleton)
            # say color
            soundhandle.stopAll()
            soundhandle.say(rinfo.colors[len(rinfo.poses) - 1-i])
        
        #TODO cylinders
        

    plt.close()
    fig, axes = plt.subplots(1, 5, figsize=(8, 4), sharex=True, sharey=True)
    ax = axes.ravel()

    ax[0].imshow(dilatedOriginal, cmap=plt.cm.gray)
    ax[0].set_title('dilated')
    ax[0].axis('off')

    ax[1].imshow(skeleton, cmap=plt.cm.gray)
    ax[1].set_title('skeletonized')
    ax[1].axis('off')

    ax[2].imshow(cv_map, cmap=plt.cm.gray)
    ax[2].set_title('original')
    ax[2].axis('off')

    ax[3].imshow(rgb, cmap=plt.cm.gray)
    ax[3].set_title('rgb representation')
    ax[3].axis('off')

    ax[4].imshow(move_map, cmap=plt.cm.gray)
    ax[4].set_title('moved')
    ax[4].axis('off')


    fig.tight_layout()
    plt.show()

   

    pt = PointStamped()
    pt.point.x = x_current * map_resolution
    pt.point.y = (heigth - y_current) * map_resolution
    pt.point.z = 0.0

    #print(pt)


    pose_transformed = tf2_geometry_msgs.do_transform_point(pt, map_transform)

   # print(pose_transformed)

    
    #tf2::doTransform(pt, transformed_pt, map_transform);


        


import matplotlib.pyplot as plt
if __name__ == '__main__':
    main()